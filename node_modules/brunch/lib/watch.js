// Generated by CoffeeScript 1.9.1
'use strict';
var BrunchWatcher, bindWatcherEvents, changeFileList, chokidar, debug, each, fs_utils, generateCompilationLog, generateParams, getCompileFn, getPluginIncludes, getPlugins, getReloadFn, helpers, initWatcher, initialize, isConfigFile, isPluginFor, loadPackages, logger, propIsFunction, pushserve, spawn, startServer, sysPath, watch, waterfall, worker,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

each = require('async-each');

waterfall = require('async-waterfall');

chokidar = require('chokidar');

debug = require('debug')('brunch:watch');

sysPath = require('path');

spawn = require('child_process').spawn;

logger = require('loggy');

pushserve = require('pushserve');

worker = require('./worker');

fs_utils = require('./fs_utils');

helpers = require('./helpers');

getPluginIncludes = function(plugins) {
  var ensureArray, getValue;
  getValue = function(thing, context) {
    if (context == null) {
      context = this;
    }
    if (typeof thing === 'function') {
      return thing.call(context);
    } else {
      return thing;
    }
  };
  ensureArray = function(object) {
    if (Array.isArray(object)) {
      return object;
    } else {
      return [object];
    }
  };
  return plugins.map(function(plugin) {
    return getValue(plugin.include, plugin);
  }).filter(function(paths) {
    return paths != null;
  }).reduce((function(acc, elem) {
    return acc.concat(ensureArray(elem));
  }), []);
};

propIsFunction = function(prop) {
  return function(object) {
    return typeof object[prop] === 'function';
  };
};

generateParams = function(persistent, options) {
  var params, ref;
  params = {
    env: ((ref = options.env) != null ? ref.split(',') : void 0) || []
  };
  if ((options.production != null) || (options.optimize != null)) {
    params.env.unshift('production');
  }
  params.persistent = persistent;
  params.stdin = options.stdin != null;
  if (options.publicPath) {
    params.paths = {};
    params.paths["public"] = options.publicPath;
  }
  if (persistent) {
    params.server = {};
    if (options.server) {
      params.server.run = true;
    }
    if (options.port) {
      params.server.port = options.port;
    }
  }
  return params;
};

startServer = function(config, callback) {
  var child, commandComponents, customServerTimeout, error, opts, port, publicPath, server, serverCb, serverConfig, serverFn, serverOpts;
  if (callback == null) {
    callback = function() {};
  }
  serverOpts = config.server || {};
  port = parseInt(config.server.port, 10);
  publicPath = config.paths["public"];
  serverCb = function() {
    clearTimeout(customServerTimeout);
    logger.info(config.server.path || config.server.command ? 'custom server started, initializing watcher' : "application started on http://localhost:" + port + "/");
    return callback();
  };
  if (config.server.path) {
    logger.info('starting custom server');
    try {
      server = require(sysPath.resolve(config.server.path));
    } catch (_error) {
      error = _error;
      logger.error("couldn't load server " + config.server.path + ": " + error);
    }
    serverFn = (function() {
      if (typeof server === 'function') {
        return server;
      } else if (typeof (server != null ? server.startServer : void 0) === 'function') {
        return server.startServer.bind(server);
      } else {
        throw new Error('Brunch server file needs to have startServer function');
      }
    })();
    opts = {
      port: port,
      path: publicPath
    };
    serverConfig = helpers.extend(opts, serverOpts.config || {});
    debug("Invoking custom startServer with: " + (JSON.stringify(serverConfig)));
    customServerTimeout = setTimeout(function() {
      logger.warn('custom server taking a long time to start');
      return logger.warn('**don\'t forget to invoke callback()**');
    }, 5000);
    switch (serverFn.length) {
      case 1:
        return serverFn(serverCb);
      case 2:
        return serverFn(serverConfig, serverCb);
      default:
        return serverFn(port, publicPath, serverCb);
    }
  } else if (config.server.command) {
    commandComponents = config.server.command.split(' ');
    debug("Invoking custom server command with: " + config.server.command);
    if (!commandComponents.length) {
      throw new Error('Custom server command invalid');
    }
    child = spawn(commandComponents.shift(), commandComponents, {
      stdio: 'inherit'
    });
    child.close = (function(_this) {
      return function(cb) {
        child.kill();
        return typeof cb === "function" ? cb() : void 0;
      };
    })(this);
    serverCb();
    return child;
  } else {
    opts = {
      noLog: true,
      path: publicPath
    };
    return pushserve(helpers.extend(opts, serverOpts), serverCb);
  }
};

initWatcher = function(config, callback) {
  var allConfigFiles, bower, component, exists, getFiles, npm, ref, watched;
  allConfigFiles = config._normalized.paths.allConfigFiles;
  ref = config._normalized.packageInfo, npm = ref.npm, bower = ref.bower, component = ref.component;
  getFiles = function(pkgs) {
    return [].concat.apply([], pkgs.components.map(function(_) {
      return _.files;
    }));
  };
  watched = config.paths.watched.concat(allConfigFiles, getFiles(npm), getFiles(bower), getFiles(component));
  exists = function(path, callback) {
    return fs_utils.exists(path, function(value) {
      return callback(void 0, value);
    });
  };
  return each(watched, exists, function(err, existing) {
    var params, ref1, watchedFiles;
    watchedFiles = watched.filter(function(_, index) {
      return existing[index];
    });
    params = {
      ignored: fs_utils.ignored,
      persistent: config.persistent,
      usePolling: (ref1 = config.watcher) != null ? ref1.usePolling : void 0
    };
    return callback(null, chokidar.watch(watchedFiles, params));
  });
};

isPluginFor = function(path) {
  return function(plugin) {
    var pattern;
    pattern = plugin.pattern ? plugin.pattern : plugin.extension ? RegExp("\\." + plugin.extension + "$") : /$0^/;
    return pattern.test(path);
  };
};

changeFileList = function(compilers, linters, fileList, path, isHelper) {
  var compiler, currentLinters;
  compiler = compilers.filter(isPluginFor(path));
  currentLinters = linters.filter(isPluginFor(path));
  return fileList.emit('change', path, compiler, currentLinters, isHelper);
};

generateCompilationLog = function(startTime, allAssets, generatedFiles, disposedFiles) {
  var assetsLog, cachedCount, cachedCountName, cachedLog, compiled, compiledCount, compiledLog, copied, copiedCount, diff, disposedCount, generated, generatedLog, getName, main, nonAssetsLog, noun, sep;
  getName = function(file) {
    return sysPath.basename(file.path);
  };
  copied = allAssets.filter(function(_) {
    return _.copyTime > startTime;
  }).map(getName);
  generated = [];
  compiled = [];
  cachedCount = 0;
  generatedFiles.forEach(function(generatedFile) {
    var isChanged, locallyCompiledCount;
    isChanged = false;
    locallyCompiledCount = 0;
    generatedFile.sourceFiles.forEach(function(sourceFile) {
      var sourceName;
      if (sourceFile.compilationTime >= startTime) {
        isChanged = true;
        locallyCompiledCount += 1;
        sourceName = getName(sourceFile);
        if (indexOf.call(compiled, sourceName) < 0) {
          compiled.push(sourceName);
        }
      }
      if (!isChanged && indexOf.call(disposedFiles.generated, generatedFile) >= 0) {
        return isChanged = true;
      }
    });
    if (isChanged) {
      generated.push(getName(generatedFile));
      return cachedCount += generatedFile.sourceFiles.length - locallyCompiledCount;
    }
  });
  compiledCount = compiled.length;
  copiedCount = copied.length;
  disposedCount = disposedFiles.sourcePaths.length;
  generatedLog = (function() {
    switch (generated.length) {
      case 0:
        return '';
      case 1:
        return " into " + generated[0];
      default:
        return " into " + generated.length + " files";
    }
  })();
  compiledLog = (function() {
    switch (compiledCount) {
      case 0:
        switch (disposedCount) {
          case 0:
            return '';
          case 1:
            return "removed " + disposedFiles.sourcePaths[0];
          default:
            return "removed " + disposedCount;
        }
        break;
      case 1:
        return "compiled " + compiled[0];
      default:
        return "compiled " + compiledCount;
    }
  })();
  cachedLog = (function() {
    switch (cachedCount) {
      case 0:
        if (compiledCount <= 1) {
          return '';
        } else {
          return ' files';
        }
        break;
      default:
        switch (compiledCount) {
          case 0:
            noun = generated.length > 1 ? '' : ' files';
            return " and wrote " + cachedCount + " cached" + noun;
          case 1:
            cachedCountName = "file" + (cachedCount === 1 ? '' : 's');
            return " and " + cachedCount + " cached " + cachedCountName;
          default:
            return " files and " + cachedCount + " cached";
        }
    }
  })();
  nonAssetsLog = compiledLog + cachedLog + generatedLog;
  sep = nonAssetsLog && copiedCount !== 0 ? ', ' : '';
  assetsLog = (function() {
    switch (copiedCount) {
      case 0:
        return '';
      case 1:
        return "copied " + copied[0];
      default:
        if (compiled.length === 0) {
          return "copied " + copiedCount + " files";
        } else {
          return "copied " + copiedCount;
        }
    }
  })();
  main = nonAssetsLog + sep + assetsLog;
  diff = Date.now() - startTime;
  return (main ? main : 'compiled') + " in " + diff + "ms";
};

getCompileFn = function(config, joinConfig, fileList, optimizers, watcher, preCompile, callback) {
  return function(startTime, watcherReady) {
    var assetErrors, writeCb;
    assetErrors = fileList.getAssetErrors();
    if (assetErrors != null) {
      assetErrors.forEach(function(error) {
        return logger.error(error);
      });
      return;
    }
    writeCb = function(error, generatedFiles, disposed) {
      if (error != null) {
        if (Array.isArray(error)) {
          error.forEach(function(subError) {
            return logger.error(subError);
          });
        } else {
          logger.error(error);
        }
      } else {
        logger.info(generateCompilationLog(startTime, fileList.assets, generatedFiles, disposed));
        callback(generatedFiles);
      }
      if (!watcherReady) {
        return;
      }
      if (!config.persistent) {
        watcher.close();
        worker.close();
        process.on('exit', function(previousCode) {
          return process.exit((logger.errorHappened ? 1 : previousCode));
        });
      }
      return fileList.initial = false;
    };
    if (preCompile) {
      return preCompile(function(error) {
        if (error != null) {
          return logger.error(error);
        } else {
          return fs_utils.write(fileList, config, joinConfig, optimizers, startTime, writeCb);
        }
      });
    } else {
      return fs_utils.write(fileList, config, joinConfig, optimizers, startTime, writeCb);
    }
  };
};

getReloadFn = function(config, options, onCompile, watcher, server, plugins) {
  return function(reInstall) {
    var reWatch;
    reWatch = function() {
      var restart;
      restart = function() {
        watcher.close();
        worker.close();
        return watch(config.persistent, null, options, onCompile);
      };
      plugins.forEach(function(plugin) {
        return typeof plugin.teardown === "function" ? plugin.teardown() : void 0;
      });
      if ((server != null ? server.close : void 0) != null) {
        return server.close(restart);
      } else {
        return restart();
      }
    };
    if (reInstall) {
      return helpers.install(config.paths.root, 'npm', reWatch);
    } else {
      logger.info("Reloading watcher...");
      return reWatch();
    }
  };
};

getPlugins = function(packages, config) {
  return packages.filter(function(plugin) {
    var ref, ref1, ref2, ref3, ref4, ref5;
    if (worker.isWorker && ((ref = config.workers) != null ? ref.extensions : void 0)) {
      if (ref1 = (ref2 = plugin.prototype) != null ? ref2.extension : void 0, indexOf.call(config.workers.extensions, ref1) < 0) {
        return false;
      }
    }
    return ((ref3 = plugin.prototype) != null ? ref3.brunchPlugin : void 0) && (!worker.isWorker || ((ref4 = plugin.prototype) != null ? ref4.compile : void 0) || ((ref5 = plugin.prototype) != null ? ref5.lint : void 0));
  }).map(function(plugin) {
    var instance;
    instance = new plugin(config);
    instance.brunchPluginName = plugin.brunchPluginName;
    return instance;
  });
};

loadPackages = function(rootPath, callback) {
  var devPlugins, err, json, loadDeps, nodeModules, optPlugins, packagePath, plugins;
  rootPath = sysPath.resolve(rootPath);
  nodeModules = rootPath + "/node_modules";
  try {
    packagePath = sysPath.join(rootPath, 'package.json');
    delete require.cache[require.resolve(packagePath)];
    json = require(packagePath);
  } catch (_error) {
    err = _error;
    throw new Error("Current directory is not brunch application root path, as it does not contain package.json (" + err + ")");
  }
  loadDeps = function(deps, isDev) {
    var requireModule;
    requireModule = function(depPath, dependencyName) {
      var plugin;
      plugin = require(depPath);
      plugin.brunchPluginName = dependencyName;
      return plugin;
    };
    return deps.filter(function(dependency) {
      return dependency !== 'brunch' && dependency.indexOf('brunch') !== -1;
    }).map(function(dependency) {
      var depPath, e, error;
      depPath = nodeModules + "/" + dependency;
      if (isDev) {
        try {
          return requireModule(depPath, dependency);
        } catch (_error) {
          e = _error;
          return null;
        }
      } else {
        try {
          return requireModule(depPath, dependency);
        } catch (_error) {
          error = _error;
          throw new Error("You probably need to execute `npm install` to install brunch plugins. " + error);
        }
      }
    });
  };
  plugins = loadDeps(Object.keys(json.dependencies || {}));
  devPlugins = loadDeps(Object.keys(json.devDependencies || {}), true);
  optPlugins = loadDeps(Object.keys(json.optionalDependencies || {}), true);
  return plugins.concat(devPlugins.concat(optPlugins).filter(function(_) {
    return _ != null;
  }));
};

initialize = function(options, configParams, onCompile, callback) {
  return helpers.loadConfig(options.config, configParams, function(error, config) {
    var alwaysEnabled, callCompileCallbacks, callPreCompillers, callbacks, compilers, fileList, joinConfig, launchWatcher, linters, optimizers, packages, plugins, preCompilers, server, unfiltered;
    logger.notifications = config.notifications;
    logger.notificationsTitle = config.notificationsTitle || 'Brunch';
    if (options.config != null) {
      logger.warn('`-c, --config` option is deprecated. Use `--env` and `config.overrides` instead');
    }
    if (options.optimize != null) {
      logger.warn('`-o, --optimize` option is deprecated. Use `-P, --production` instead');
    }
    joinConfig = config._normalized.join;
    packages = (loadPackages('.')).filter(function(arg) {
      var brunchPluginName, ref, ref1;
      brunchPluginName = arg.brunchPluginName;
      if (((ref = config.plugins.off) != null ? ref.length : void 0) && indexOf.call(config.plugins.off, brunchPluginName) >= 0) {
        return false;
      } else if (((ref1 = config.plugins.only) != null ? ref1.length : void 0) && indexOf.call(config.plugins.only, brunchPluginName) < 0) {
        return false;
      } else {
        return true;
      }
    });
    unfiltered = getPlugins(packages, config);
    alwaysEnabled = config.plugins.on || [];
    plugins = unfiltered.filter(function(plugin) {
      var env, ref;
      if (typeof plugin.minify === 'function') {
        if (plugin.optimize == null) {
          plugin.optimize = plugin.minify;
        }
      }
      if (ref = plugin.brunchPluginName, indexOf.call(alwaysEnabled, ref) >= 0) {
        return true;
      }
      if (plugin.optimize && !plugin.defaultEnv) {
        return config.optimize;
      }
      env = plugin.defaultEnv != null ? plugin.defaultEnv : plugin.defaultEnv = '*';
      return env === '*' || indexOf.call(config.env, env) >= 0;
    });
    debug("Loaded plugins: " + (plugins.map(function(plugin) {
      return plugin.brunchPluginName;
    }).join(', ')));
    compilers = plugins.filter(propIsFunction('compile'));
    linters = plugins.filter(propIsFunction('lint'));
    optimizers = plugins.filter(propIsFunction('optimize'));
    preCompilers = plugins.filter(propIsFunction('preCompile')).map(function(plugin) {
      return function() {
        var args, cb, i;
        args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
        return plugin.preCompile(cb);
      };
    });
    if (typeof config.preCompile === 'function') {
      preCompilers.push(function() {
        var args, cb, i;
        args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), cb = arguments[i++];
        return config.preCompile(cb);
      });
    }
    callPreCompillers = function(cb) {
      return waterfall(preCompilers, cb);
    };
    callbacks = plugins.filter(propIsFunction('onCompile')).map(function(plugin) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return plugin.onCompile.apply(plugin, args);
      };
    });
    if (typeof config.onCompile === 'function') {
      callbacks.push(config.onCompile);
    }
    callbacks.push(onCompile);
    callCompileCallbacks = function(generatedFiles) {
      return callbacks.forEach(function(callback) {
        return callback(generatedFiles);
      });
    };
    fileList = new fs_utils.FileList(config);
    if (worker.isWorker) {
      return callback(null, {
        config: config,
        fileList: fileList,
        compilers: compilers,
        linters: linters
      });
    }
    launchWatcher = function() {
      return initWatcher(config, function(error, watcher) {
        var compile, includes, reload;
        if (error != null) {
          return callback(error);
        }
        compile = getCompileFn(config, joinConfig, fileList, optimizers, watcher, callPreCompillers, callCompileCallbacks);
        reload = getReloadFn(config, options, onCompile, watcher, server, plugins);
        includes = getPluginIncludes(plugins);
        return callback(error, {
          config: config,
          watcher: watcher,
          server: server,
          fileList: fileList,
          compilers: compilers,
          linters: linters,
          compile: compile,
          reload: reload,
          includes: includes
        });
      });
    };
    if (config.persistent && config.server.run) {
      return server = startServer(config, launchWatcher);
    } else {
      return launchWatcher();
    }
  });
};

isConfigFile = function(basename, configPath) {
  var files;
  files = Object.keys(require.extensions).map(function(_) {
    return configPath + _;
  });
  return files.some(function(file) {
    return basename === file;
  });
};

bindWatcherEvents = function(config, fileList, compilers, linters, watcher, reload, onChange) {
  var bowerConfig, changeHandler, packageConfig, possibleConfigFiles, ref;
  possibleConfigFiles = config._normalized.paths.possibleConfigFiles;
  ref = config.paths, packageConfig = ref.packageConfig, bowerConfig = ref.bowerConfig;
  changeHandler = function(path) {
    onChange();
    return changeFileList(compilers, linters, fileList, path, false);
  };
  if (config.persistent && config.stdin) {
    process.stdin.on('end', function() {
      return process.exit(0);
    });
    process.stdin.resume();
  }
  watcher.on('error', logger.error).on('add', function(absPath) {
    var isPluginsFile, path;
    path = sysPath.relative(config.paths.root, absPath);
    isConfigFile = possibleConfigFiles[path];
    isPluginsFile = path === packageConfig || path === bowerConfig;
    if (!(isConfigFile || isPluginsFile)) {
      return changeHandler(path);
    }
  }).on('change', function(absPath) {
    var isPackageFile, path;
    path = sysPath.relative(config.paths.root, absPath);
    isConfigFile = possibleConfigFiles[path];
    isPackageFile = path === packageConfig;
    if (isConfigFile || isPackageFile) {
      return reload(isPackageFile);
    } else if (path === bowerConfig) {
      return helpers.install(config.paths.root, 'bower', reload);
    } else {
      return changeHandler(path);
    }
  }).on('unlink', function(absPath) {
    var isPackageFile, path;
    path = sysPath.relative(config.paths.root, absPath);
    isConfigFile = possibleConfigFiles[path];
    isPackageFile = path === packageConfig;
    if (isConfigFile || isPackageFile) {
      logger.info("Detected removal of config.coffee / package.json.\nExiting.");
      return process.exit(0);
    } else {
      onChange();
      return fileList.emit('unlink', path);
    }
  });
  if (process.env.DEBUG) {
    return watcher.on('all', function(event, path) {
      return debug("File '" + path + "' received event '" + event + "'");
    });
  }
};

BrunchWatcher = (function() {
  function BrunchWatcher(persistent, options, onCompile) {
    this._endCompilation = bind(this._endCompilation, this);
    this._startCompilation = bind(this._startCompilation, this);
    var configParams;
    this._start = Date.now();
    configParams = generateParams(persistent, options);
    initialize(options, configParams, onCompile, (function(_this) {
      return function(error, result) {
        var compile, compilers, fileList, includes, linters, ref, reload, watcher, watcherReady;
        if (error != null) {
          return logger.error(error);
        }
        _this.config = result.config, watcher = result.watcher, fileList = result.fileList, compilers = result.compilers, linters = result.linters, compile = result.compile, reload = result.reload, includes = result.includes;
        if ((ref = _this.config.workers) != null ? ref.enabled : void 0) {
          if (!worker({
            changeFileList: changeFileList,
            compilers: compilers,
            linters: linters,
            fileList: fileList,
            config: _this.config
          })) {
            return;
          }
        }
        bindWatcherEvents(_this.config, fileList, compilers, linters, watcher, reload, _this._startCompilation);
        watcherReady = false;
        watcher.once('ready', function() {
          return watcherReady = true;
        });
        fileList.on('ready', function() {
          if (_this._start) {
            return compile(_this._endCompilation(), watcherReady);
          }
        });
        return includes.forEach(function(path) {
          var relative;
          relative = sysPath.relative(_this.config.paths.root, path);
          return changeFileList(compilers, linters, fileList, relative, true);
        });
      };
    })(this));
  }

  BrunchWatcher.prototype._startCompilation = function() {
    return this._start != null ? this._start : this._start = Date.now();
  };

  BrunchWatcher.prototype._endCompilation = function() {
    var start;
    start = this._start;
    this._start = null;
    return start;
  };

  return BrunchWatcher;

})();

module.exports = watch = function(persistent, path, options, callback) {
  if (callback == null) {
    callback = (function() {});
  }
  if (path) {
    if (typeof path === 'string') {
      process.chdir(path);
    } else {
      if (typeof 'options' === 'function') {
        callback = options;
      }
      options = path;
    }
  }
  return new BrunchWatcher(persistent, options, callback);
};

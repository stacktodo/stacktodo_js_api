// Generated by CoffeeScript 1.9.1
'use strict';
var SourceFile, SourceMapConsumer, SourceMapGenerator, SourceNode, debug, helpers, identityNode, isWindows, makeCompiler, makeWrapper, pipeline, replaceBackSlashes, smap, updateCache, updateMap;

debug = require('debug')('brunch:source-file');

pipeline = require('./pipeline').pipeline;

helpers = require('../helpers');

identityNode = helpers.identityNode, replaceBackSlashes = helpers.replaceBackSlashes, isWindows = helpers.isWindows;

smap = require('source-map');

SourceMapConsumer = smap.SourceMapConsumer, SourceMapGenerator = smap.SourceMapGenerator, SourceNode = smap.SourceNode;

updateMap = function(path, compiled, wrapped, sourceMap) {
  var map, mapping, node, prefix, sourcePos, suffix, wrapperContent;
  if (sourceMap) {
    debug("Generated source map for '" + path + "' ");
  }
  if (typeof wrapped === 'object') {
    prefix = wrapped.prefix, suffix = wrapped.suffix;
    wrapperContent = wrapped.data || compiled;
  } else {
    sourcePos = wrapped.indexOf(compiled);
    wrapperContent = sourcePos > 0 ? compiled : wrapped;
    prefix = wrapped.slice(0, sourcePos);
    suffix = wrapped.slice(sourcePos + compiled.length);
  }
  node = sourceMap ? (mapping = typeof sourceMap === 'string' ? JSON.parse(sourceMap.replace(/^\)\]\}'/, '')) : sourceMap, isWindows && mapping.sources ? mapping.sources = mapping.sources.map(replaceBackSlashes) : void 0, map = new SourceMapConsumer(mapping), SourceNode.fromStringWithSourceMap(wrapperContent, map)) : identityNode(wrapperContent, path);
  node.isIdentity = sourceMap == null;
  if (prefix) {
    node.prepend(prefix);
  }
  if (suffix) {
    node.add(suffix);
  }
  node.source = path;
  node.setSourceContent(path, wrapperContent);
  return node;
};

updateCache = function(path, cache, error, result, wrap) {
  var compiled, source, wrapped;
  if (error != null) {
    cache.error = error;
    return cache;
  }
  if (result == null) {
    cache.error = null;
    cache.data = null;
    cache.compilationTime = Date.now();
    return cache;
  }
  source = result.source, compiled = result.compiled;
  wrapped = wrap(compiled);
  cache.error = null;
  cache.dependencies = result.dependencies;
  cache.source = source;
  cache.compilationTime = Date.now();
  cache.data = compiled;
  cache.node = updateMap(path, compiled, wrapped, result.sourceMap);
  return cache;
};

makeWrapper = function(wrapper, path, isWrapped, isntModule) {
  return function(node) {
    if (isWrapped) {
      return wrapper(path, node, isntModule);
    } else {
      return node;
    }
  };
};

makeCompiler = function(path, cache, linters, compilers, wrap) {
  var normalizedPath;
  normalizedPath = replaceBackSlashes(path);
  return function(callback) {
    return pipeline(path, linters, compilers, (function(_this) {
      return function(error, data) {
        updateCache(normalizedPath, cache, error, data, wrap);
        return callback(error, cache.data);
      };
    })(this));
  };
};

module.exports = SourceFile = (function() {
  function SourceFile(path1, compilers, linters, wrapper, isHelper, isVendor) {
    var compiler, isWrapped, isntModule, ref, wrap;
    this.path = path1;
    this.isHelper = isHelper;
    compiler = compilers[0];
    isntModule = this.isHelper || isVendor;
    isWrapped = (ref = compiler.type) === 'javascript' || ref === 'template';
    this.type = compiler.type;
    this.source = null;
    this.data = '';
    this.node = null;
    this.dependencies = [];
    this.compilationTime = null;
    this.error = null;
    this.removed = false;
    this.disposed = false;
    wrap = makeWrapper(wrapper, this.path, isWrapped, isntModule);
    this.compile = makeCompiler(this.path, this, linters, compilers, wrap);
    debug("Initializing fs_utils.SourceFile: %s", JSON.stringify({
      path: this.path,
      isntModule: isntModule,
      isWrapped: isWrapped
    }));
    Object.seal(this);
  }

  SourceFile.prototype.dispose = function() {
    debug("Disposing '" + this.path + "'");
    this.path = '';
    this.data = '';
    this.dependencies = [];
    this.disposed = true;
    return Object.freeze(this);
  };

  return SourceFile;

})();

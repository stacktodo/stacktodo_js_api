{"version":3,"sources":["stacktodo/core/ajax.js","stacktodo/core/form.js","stacktodo/core/jsoncors.js","stacktodo/slack_form.js","stacktodo/slack_invite.js","stacktodo/slack_publish.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bin/stacktodo.js","sourcesContent":["(function(ns) {\n\t\n\t/**\n\t* AJAX Utility\n\t* Wraps up all the ajax stuff into a simple wrapper\n\t*/\n\tvar AJAX = function() {\n\t\tvar self = this;\n\n\t\t/********************************************************************************/\n\t\t// GET\n\t\t/********************************************************************************/\n\n\t\t/**\n\t\t* Performs a get on the given endpoint\n\t\t* @param url=/: the url to post to\n\t\t* @param success=undefined: executed on http success with the response\n\t\t* @param failure=undefined: executed on http failure\n\t\t* @param complete=undefined: executed after http success or failure\n\t\t* Returns the xhr object\n\t\t*/\n\t\tself.get = function(options) {\n\t\t\toptions = {\n\t\t\t\turl \t\t: options.url || window.location.href,\n\t\t\t\tsuccess \t: options.success || function() {},\n\t\t\t\tfailure \t: options.failure || function() {},\n\t\t\t\tcomplete \t: options.complete || function() {}\n\t\t\t};\n\n\t\t\tvar xhr;\n\t\t\tif (typeof XDomainRequest != 'undefined') {\n\t\t\t\txhr = new XDomainRequest();\n\t\t\t\txhr.open('GET', options.url);\n\t\t\t} else {\n\t\t\t\txhr = new XMLHttpRequest();\n\t\t\t\txhr.open('GET', options.url, true);\n\t\t\t}\n\n\t\t\txhr.onload = function() {\n\t\t\t\tif (xhr.status >= 200 && xhr.status <= 299) {\n\t\t\t\t\toptions.success(xhr.responseText, xhr.status, xhr);\n\t\t\t\t} else {\n\t\t\t\t\toptions.failure(xhr.status, xhr.responseText, xhr);\n\t\t\t\t}\n\t\t\t\toptions.complete();\n\t\t  \t};\n\n\t\t  \txhr.onerror = function() {\n\t\t  \t\toptions.failure(xhr.status, undefined, xhr);\n\t\t  \t\toptions.complete();\n\t\t  \t};\n\n\t\t\txhr.send();\n\t\t\treturn xhr;\n\t\t};\n\t};\n\t\n\tns.stacktodo = ns.stacktodo || {};\n\tns.stacktodo.core = ns.stacktodo.core || {};\n\tns.stacktodo.core.ajax = new AJAX();\n})(window);","(function(ns) {\n\t\n\t/**\n\t* Form utility\n\t* Wraps up some form utilities\n\t*/\n\tvar Form = function() {\n\t\tvar self = this;\n\n\t\t/**\n\t\t* Serializes a form\n\t\t* @param formElement: the form element to serialize\n\t\t* @return a map of key to value\n\t\t*/\n\t\tself.serialize = function(formElement) {\n\t\t\tvar values = { };\n\t\t\tvar elems = {\n\t\t\t\tinput  \t\t: formElement.getElementsByTagName('input'),\n\t\t\t\ttextarea \t: formElement.getElementsByTagName('textarea'),\n\t\t\t\tselect \t\t: formElement.getElementsByTagName('select')\n\t\t\t};\n\n\t\t\t// Serialize inputs\n\t\t\tfor (var i = 0; i < elems.input.length; i++) {\n\t\t\t\tvar name = elems.input[i].name;\n\t\t\t\tif (name === undefined || name.length === 0) { continue; }\n\t\t\t\tvar type = elems.input[i].type;\n\n\t\t\t\tif (type === 'checkbox') {\n\t\t\t\t\tif (elems.input[i].checked) {\n\t\t\t\t\t\tvalues[name] = values[name] || [];\n\t\t\t\t\t\tvalues[name].push(elems.input[i].value);\n\t\t\t\t\t}\n\t\t\t\t} else if (type === 'radio') {\n\t\t\t\t\tif (elems.input[i].checked) {\n\t\t\t\t\t\tvalues[name] = values[elems.input[i].value];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalues[name] = values[name] || [];\n\t\t\t\t\tvalues[name].push(elems.input[i].value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Serialize textareas\n\t\t\tfor (var t = 0; t < elems.textarea.length; t++) {\n\t\t\t\tvar name = elems.textarea[t].name;\n\t\t\t\tif (name === undefined || name.length === 0) { continue; }\n\t\t\t\tvalues[name] = values[name] || [];\n\t\t\t\tvalues[name].push(elems.textarea[t].value);\n\t\t\t}\n\n\t\t\t// Serialize selects\n\t\t\tfor (var s = 0; i < elems.select.length; s++) {\n\t\t\t\tvar name = elems.select[s].name;\n\t\t\t\tif (name === undefined || name.length === 0) { continue; }\n\n\t\t\t\tvar options = elems.select[s].getElementsByTagName('option');\n\t\t\t\tfor (var o = 0; o < options.length; o++) {\n\t\t\t\t\tif (options[o].selected) {\n\t\t\t\t\t\tvalues[name] = values[name] || [];\n\t\t\t\t\t\tvalues[name].push(options[o].value)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Reduce the values with a single value to be straight values\n\t\t\tfor (var k in values) {\n\t\t\t\tif (values[k].length === 1) {\n\t\t\t\t\tvalues[k] = values[k][0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn values\n\t\t};\n\n\t\treturn self;\n\t};\n\t\n\tns.stacktodo = ns.stacktodo || {};\n\tns.stacktodo.core = ns.stacktodo.core || {};\n\tns.stacktodo.core.form = new Form();\n})(window);","(function(ns) {\n\t\n\t/**\n\t* JSON CORS utility\n\t* Wraps up all the cors stuff into a simple post or get. Falls back to jsonp\n\t*/\n\tvar JSONCORS = function() {\n\t\tvar self = this;\n\t\tvar supportsCORS = ('withCredentials' in new XMLHttpRequest()) || (typeof XDomainRequest != 'undefined');\n\n\t\t/********************************************************************************/\n\t\t// Utils\n\t\t/********************************************************************************/\n\n\t\t/**\n\t\t* Serializes a dictionary into a url query\n\t\t* @param m: the map to serialize\n\t\t* @return the url query (no preceeding ?)\n\t\t*/\n\t\tvar serializeURLQuery = function(m) {\n\t\t\tvar args = [];\n\t\t\tfor (var k in m) {\n\t\t\t\targs.push(encodeURIComponent(k) + '=' + encodeURIComponent(m[k]))\n\t\t\t}\n\t\t\treturn args.join('&');\n\t\t};\n\n\t\t/********************************************************************************/\n\t\t// CORS\n\t\t/********************************************************************************/\n\n\t\t/**\n\t\t* Performs a CORS request which wraps the response through our marshalled API\n\t\t* @param url: the url to visit\n\t\t* @param method: GET|POST the http method\n\t\t* @param payload: the payload to send (undefined for GET)\n\t\t* @param success: executed on success. Given response then http status then xhr\n\t\t* @param failure: executed on failure. Given http status then error then xhr\n\t\t* @return the XHR object\n\t\t*/\n\t\tself.requestCORS = function(url, method, payload, success, failure) {\n\t\t\tmethod = method.toUpperCase();\n\t\t\tvar xhr;\n\t\t\tif (typeof XDomainRequest != 'undefined') {\n\t\t\t\txhr = new XDomainRequest();\n\t\t\t\txhr.open(method, url);\n\t\t\t} else {\n\t\t\t\txhr = new XMLHttpRequest();\n\t\t\t\txhr.open(method, url, true);\n\t\t\t}\n\n\t\t\txhr.onload = function() {\n\t\t\t\tvar json;\n\t\t\t\ttry { json = JSON.parse(xhr.responseText); } catch(e) { /* noop */ }\n\t\t\t\tvar status = (json && json.http_status !== undefined) ? json.http_status : xhr.status;\n\n\t\t\t\tif (status >= 200 && status <= 299) {\n\t\t\t\t\tsuccess(json, status, xhr);\n\t\t\t\t} else {\n\t\t\t\t\tfailure(xhr.status, json ? json.error : undefined, xhr);\n\t\t\t\t}\n\t\t  \t};\n\n\t\t  \txhr.onerror = function() {\n\t\t  \t\tfailure(xhr.status, undefined, xhr);\n\t\t  \t};\n\n\t\t\tif (method === 'POST') {\n\t\t\t\txhr.setRequestHeader(\"Content-type\",\"application/json\");\n\t\t\t\txhr.send(JSON.stringify(payload));\n\t\t\t} else {\n\t\t\t\txhr.send();\n\t\t\t}\n\t\t\t\n\t\t\treturn xhr;\n\t\t};\n\n\t\t/********************************************************************************/\n\t\t// JSONP\n\t\t/********************************************************************************/\n\n\t\t/**\n\t\t* Performs a JSONP request which wraps the response through our marshalled API\n\t\t* @param url: the url to visit\n\t\t* @param method: GET|POST the http method\n\t\t* @param payload: the payload to send (undefined for GET)\n\t\t* @param success: executed on success. Given response then http status then xhr\n\t\t* @param failure: executed on failure. Given http status then error then xhr\n\t\t* @return the XHR object\n\t\t*/\n\t\tself.requestJSONP = function(url, method, payload, success, failure) {\n\t\t\tmethod = method.toUpperCase();\n\n\t\t\tvar jsonp = document.createElement('script');\n\t\t\tjsonp.type = 'text/javascript';\n\n\t\t\t// Success callback\n\t\t\tvar id = '__jsonp_' + Math.ceil(Math.random() * 10000);\n\t\t\tvar dxhr = { jsonp:true, id:id, response:undefined };\n\t\t\twindow[id] = function(r) {\n\t\t\t\tjsonp.parentElement.removeChild(jsonp);\n\t\t\t\tdelete window[id];\n\t\t\t\tdxhr.response = r;\n\n\t\t\t\tif (r === undefined || r === null) {\n\t\t\t\t\tsuccess(undefined, 200, dxhr);\n\t\t\t\t} else {\n\t\t\t\t\tif (r.http_status >= 200 && r.http_status <= 299) {\n\t\t\t\t\t\tsuccess(r, r.http_status, dxhr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfailure(r.http_status, r.error, dxhr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Error callback\n\t\t\tjsonp.onerror = function() {\n\t\t\t\tjsonp.parentElement.removeChild(jsonp);\n\t\t\t\tdxhr.jsonp_transport_error = 'ScriptErrorFailure';\n\t\t\t\tfailure(0, undefined, dxhr);\n\t\t\t};\n\n\t\t\tvar urlQuery;\n\t\t\tif (method === 'POST') {\n\t\t\t\turlQuery = '?' + serializeURLQuery(payload) + '&callback=' + id + '&_=' + new Date().getTime();\n\t\t\t} else {\n\t\t\t\turlQuery = '?' + 'callback=' + id + '&_=' + new Date().getTime();\n\t\t\t}\n\n\t\t\tjsonp.src = url + urlQuery;\n\t\t\tdocument.head.appendChild(jsonp);\n\n\t\t\treturn dxhr;\n\t\t};\n\n\t\t/********************************************************************************/\n\t\t// GET\n\t\t/********************************************************************************/\n\n\t\t/**\n\t\t* Makes a get request\n\t\t* @param url=/: the url to post to\n\t\t* @param success=undefined: executed on http success with the response\n\t\t* @param failure=undefined: executed on http failure\n\t\t* @param complete=undefined: executed after http success or failure\n\t\t* Returns either the xhr request or a jsonp holding object\n\t\t*/\n\t\tself.get = function(options) {\n\t\t\tvar method = supportsCORS ? 'requestCORS' : 'requestJSONP';\n\t\t\treturn self[method](options.url || window.location.href, 'GET', undefined, function(response, status, xhr) {\n\t\t\t\tif (options.success) { options.success(response, status, xhr); }\n\t\t\t\tif (options.complete) { options.complete(); }\n\t\t\t}, function(status, error, xhr) {\n\t\t\t\tif (options.failure) { options.failure(status, error, xhr); }\n\t\t\t\tif (options.complete) { options.complete(); }\n\t\t\t});\n\t\t};\n\n\t\t/********************************************************************************/\n\t\t// POST\n\t\t/********************************************************************************/\n\n\t\t/**\n\t\t* Makes a post request\n\t\t* @param url=/: the url to post to\n\t\t* @param payload={}: the payload to send\n\t\t* @param success=undefined: executed on http success with the response\n\t\t* @param failure=undefined: executed on http failure\n\t\t* @param complete=undefined: executed after http success or failure\n\t\t* Returns either the xhr request or a jsonp holding object\n\t\t*/\n\t\tself.post = function(options) {\n\t\t\tvar method = supportsCORS ? 'requestCORS' : 'requestJSONP';\n\t\t\treturn self[method](options.url || window.location.href, 'POST', options.payload || {}, function(response, status, xhr) {\n\t\t\t\tif (options.success) { options.success(response, status, xhr); }\n\t\t\t\tif (options.complete) { options.complete(); }\n\t\t\t}, function(status, error, xhr) {\n\t\t\t\tif (options.failure) { options.failure(status, error, xhr); }\n\t\t\t\tif (options.complete) { options.complete(); }\n\t\t\t});\n\t\t};\n\n\t\treturn self;\n\t};\n\t\n\tns.stacktodo = ns.stacktodo || {};\n\tns.stacktodo.core = ns.stacktodo.core || {};\n\tns.stacktodo.core.jsoncors = new JSONCORS();\n})(window);","(function(ns) {\n\t/**\n\t* An instance that can be called up to submit a form into slack\n\t* @param formId: the id of the form record on stacktodo\n\t*/\n\tvar SlackForm = function(formId) {\n\t\tvar self = this;\n\n\t\t/**\n\t\t* Error mapping\n\t\t*/\n\t\tself.ERRORS = {\n\t\t\tEmptyFormError \t\t\t: 'EmptyFormError',\n\t\t\tUnknownFormError \t\t: 'UnknownFormError',\n\t\t\tUnknownError \t\t\t: 'UnknownError'\n\t\t};\n\n\t\t/**\n\t\t* Humanzed versions of the errors\n\t\t*/\n\t\tself.HUMANIZED_ERRORS = {\n\t\t\tEmptyFormError \t\t\t: 'Looks like you forgot to complete the form. Can you check it and try again?',\n\t\t\tUnknownFormError \t\t: 'We couldn\\'t find the form channel you\\'re trying to send to :-(',\n\t\t\tUnknownError \t\t\t: 'Something went wrong and we\\'re not quite sure what. We\\'ll look into it as soon as possible!'\n\t\t};\n\n\t\t/**\n\t\t* Humanizes the errror into a suggested error message\n\t\t*/\n\t\tself.humanizeError = function(error) {\n\t\t\treturn self.HUMANIZED_ERRORS[error] || self.HUMANIZED_ERRORS.UNKNOWN_ERROR;\n\t\t};\n\n\t\t/**\n\t\t* Prevalidates the form\n\t\t* @param values: the email to validate\n\t\t* @return self.ERRROS. or null if no errors are found\n\t\t*/\n\t\tself.preValidate = function(values) {\n\t\t\tvar count = 0;\n\t\t\tfor (var k in values) { return null; }\n\t\t\treturn self.ERRORS.EmptyFormError;\n\t\t};\n\n\t\t/**\n\t\t* Send the form to slack\n\t\t* @param form: the form to submit\n\t\t* @param success: [optional] executed on join success\n\t\t* @param failure: [optional] executed on join failure. Provided with `error` from self.ERRORS\n\t\t* @param complete: [optional] executed on completion after success or failure\n\t\t*/\n\t\tself.submit = function(form, success, failure, complete) {\n\t\t\tsuccess = success || function() { };\n\t\t\tfailure = failure || function() { };\n\t\t\tcomplete = complete || function() { };\n\n\t\t\tvar formData = ns.stacktodo.core.form.serialize(form);\n\n\t\t\tvar validationError = self.preValidate(form);\n\t\t\tif (validationError === null) {\n\t\t\t\tns.stacktodo.core.jsoncors.post({\n\t\t\t\t\turl \t\t: 'https://stacktodo.com/api/tool/form/submit',\n\t\t\t\t\tpayload \t: { id:formId, form:formData },\n\t\t\t\t\tsuccess \t: function(response, status, xhr) {\n\t\t\t\t\t\tsuccess();\n\t\t\t\t\t\tcomplete();\n\t\t\t\t\t},\n\t\t\t\t\tfailure \t: function(status, error, xhr) {\n\t\t\t\t\t\tif (!error) {\n\t\t\t\t\t\t\tswitch(status) {\n\t\t\t\t\t\t\t\tcase 404: error = self.ERRORS.UnknownFormError; break;\n\t\t\t\t\t\t\t\tdefault: error = self.ERRORS.UnknownError; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfailure(error);\n\t\t\t\t\t\tcomplete();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tfailure(validationError)\n\t\t\t\tcomplete();\n\t\t\t}\n\t\t};\n\n\t\treturn this;\n\t};\n\n\tns.stacktodo = ns.stacktodo || {};\n\tns.stacktodo.SlackForm = SlackForm;\n})(window);","(function(ns) {\n\t/**\n\t* An instance that can be called up to invite a user to join slack\n\t* @dependency: stacktodo.core.jsoncors\n\t* @param slackTeam: the name of the slackTeam e.g. `slacktodo`\n\t*/\n\tvar SlackInvite = function(slackTeam) {\n\t\tvar self = this;\n\n\t\t/**\n\t\t* Error mapping\n\t\t*/\n\t\tself.ERRORS = {\n\t\t\tMissingEmailError \t: 'MissingEmailError',\n\t\t\tInvalidEmailError \t: 'InvalidEmailError',\n\t\t\tUnknownTeamError \t: 'UnknownTeamError',\n\t\t\tUnknownError \t\t: 'UnknownError'\n\t\t};\n\n\t\t/**\n\t\t* Status mapping\n\t\t*/\n\t\tself.STATUSES = {\n\t\t\tRequestedAuthState \t: 'RequestedAuthState',\n\t\t\tInvitedUserState \t: 'InvitedUserState'\n\t\t};\n\n\t\t/**\n\t\t* Humanzed versions of the errors\n\t\t*/\n\t\tself.HUMANIZED_ERRORS = {\n\t\t\tMissingEmailError \t: 'Your email is looking awfully blank, if you fill it in we can get you started',\n\t\t\tInvalidEmailError \t: 'Your email doesn\\'t quite look right. Can you check it and try again?',\n\t\t\tUnknownTeamError \t: 'We couldn\\'t find the team you\\'re trying to join :-(',\n\t\t\tUnknownError \t\t: 'Something went wrong and we\\'re not quite sure what. We\\'ll look into it as soon as possible!'\n\t\t};\n\n\t\t/**\n\t\t* Humanized versions of the statuses\n\t\t*/\n\t\tself.HUMANIZED_STATUSES = {\n\t\t\tRequestedAuthState \t: 'Awesome your email address has been sent for approval. You should receive an invitation email from slack once you\\'ve been approved',\n\t\t\tInvitedUserState \t: 'Awesome you\\'ve been invited into the team. Check your inbox for the invitation email from slack!'\n\t\t};\n\n\t\t/**\n\t\t* Humanizes the errror into a suggested error message\n\t\t*/\n\t\tself.humanizeError = function(error) {\n\t\t\treturn self.HUMANIZED_ERRORS[error] || self.HUMANIZED_ERRORS.UNKNOWN_ERROR;\n\t\t};\n\n\t\t/**\n\t\t* Humanizes the state into a suggested status message\n\t\t*/\n\t\tself.humanizeStatus = function(status) {\n\t\t\treturn self.HUMANIZED_STATUSES[status] || self.HUMANIZED_ERRORS.UNKNOWN_ERROR;\n\t\t};\n\n\t\t/**\n\t\t* Prevalidates the email\n\t\t* @param email: the email to validate\n\t\t* @return self.ERRROS. or null if no errors are found\n\t\t*/\n\t\tself.preValidate = function(email) {\n\t\t\tif (!email || email.length === 0) {\n\t\t\t\treturn self.ERRORS.MissingEmailError;\n\t\t\t} else if (email.indexOf('@') === -1 || email.length < 7) {\n\t\t\t\treturn self.ERRORS.InvalidEmailError;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t* Extends one map into another\n\t\t* @param a: the map to extend into\n\t\t* @param b: the map to extend from\n\t\t* @return a\n\t\t*/\n\t\tvar extendMap = function(a, b) {\n\t\t\tfor (var k in b) { a[k] = b[k]; }\n\t\t\treturn a;\n\t\t};\n\n\t\t/**\n\t\t* Join the provided user to the slack team\n\t\t* @param email: the email address to join\n\t\t* @Param other_values: a dictionary of other values to submit\n\t\t* @param success: [optional] executed on join success\n\t\t* @param failure: [optional] executed on join failure. Provided with `error` from self.ERRORS\n\t\t* @param complete: [optional] executed on completion after success or failure\n\t\t*/\n\t\tself.join = function(email, other_values, success, failure, complete) {\n\t\t\tsuccess = success || function() { };\n\t\t\tfailure = failure || function() { };\n\t\t\tcomplete = complete || function() { };\n\n\t\t\tvar validationError = self.preValidate(email);\n\t\t\tif (validationError === null) {\n\t\t\t\tns.stacktodo.core.jsoncors.post({\n\t\t\t\t\turl \t\t: 'https://stacktodo.com/api/tool/invite/join',\n\t\t\t\t\tpayload \t: extendMap(other_values, { email:email, team:slackTeam }),\n\t\t\t\t\tsuccess \t: function(response, status, xhr) {\n\t\t\t\t\t\tsuccess(response.state);\n\t\t\t\t\t\tcomplete();\n\t\t\t\t\t},\n\t\t\t\t\tfailure \t: function(status, error, xhr) {\n\t\t\t\t\t\tif (!error) {\n\t\t\t\t\t\t\tswitch(status) {\n\t\t\t\t\t\t\t\tcase 404: error = self.ERRORS.UnknownTeamError; break;\n\t\t\t\t\t\t\t\tdefault: error = self.ERRORS.UnknownError; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfailure(error);\n\t\t\t\t\t\tcomplete();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tfailure(validationError)\n\t\t\t\tcomplete();\n\t\t\t}\n\t\t};\n\n\t\treturn self;\n\t};\n\n\tns.stacktodo = ns.stacktodo || {};\n\tns.stacktodo.SlackInvite = SlackInvite;\n})(window);","(function(ns) {\n\t/**\n\t* An instance that can be used to access a blog from stacktodo\n\t* @argumentset 1\n\t* \t@param taskId: the id of the task to connect to\n\t* @argumentset 2\n\t*\t@param team: the name of the team\n\t* \t@param reference: the reference of the blog\n\t*/\n\tvar SlackPublish = function() {\n\t\tvar self = this;\n\t\tvar indexUrlQuery = (function(args) {\n\t\t\tswitch(args.length) {\n\t\t\t\tcase 1: return '?id=' + encodeURIComponent(args[0]);\n\t\t\t\tcase 2: return '?team=' + encodeURIComponent(args[0]) + '&reference=' + encodeURIComponent(args[1]);\n\t\t\t\tdefault: throw('InitializationError : Incorrect params');\n\t\t\t}\n\t\t})(Array.prototype.slice.call(arguments));\n\t\tvar postsIndex = null;\n\t\tvar posts = {};\n\n\t\t/**\n\t\t* @GETTER\n\t\t* @return true if the posts index has been loaded\n\t\t*/\n\t\tself.loaded = function() { return postsIndex !== null; };\n\n\t\t/**\n\t\t* @GETTER\n\t\t* @return the amount of posts in the index\n\t\t*/\n\t\tself.count = function() { return postsIndex === null ? undefined : postsIndex.length; };\n\n\t\t/**\n\t\t* @GETTER\n\t\t* @param postId: the id of the post to get\n\t\t* @return the post head or undefined if not found\n\t\t*/\n\t\tself.postHeadForId = function(postId) {\n\t\t\tfor (var i = 0; i < (postsIndex || []).length; i++) {\n\t\t\t\tif (postsIndex[i].id === postId) { return postsIndex[i]; }\n\t\t\t}\n\t\t\treturn undefined;\n\t\t};\n\n\t\t/**\n\t\t* @GETTER\n\t\t* @param index: the index for the post\n\t\t* @return the post head or undefined if not found\n\t\t*/\n\t\tself.postHeadForIndex = function(index) { return postsIndex === null ? undefined : postsIndex[i]; };\n\n\t\t/**\n\t\t* @GETTER\n\t\t* @param postId: the id of the post\n\t\t* @return true or false if this id is the last post\n\t\t*/\n\t\tself.isPostIdLast = function(postId) {\n\t\t\tif (postsIndex === null) { return false; }\n\t\t\tif (postsIndex.length === 0) { return false; }\n\t\t\treturn postsIndex[postsIndex.length - 1].id === postId;\n\t\t};\n\n\t\t/**\n\t\t* @GETTER\n\t\t* @param lastPostId=null: the id of the previous post that you want to start from\n\t\t* @param count: the number of items to get\n\t\t* @return a list of posts to fetch or undefiend if the posts index is not loaded\n\t\t*/\n\t\tself.nextPostHeadsForRange = function(lastPostId, count) {\n\t\t\tif (postsIndex === null) { return undefined; }\n\n\t\t\t// Get the start\n\t\t\tvar start = 0;\n\t\t\tif (lastPostId) {\n\t\t\t\tfor (var i = 0; i < postsIndex.length; i++) {\n\t\t\t\t\tif (postsIndex[i].id === lastPostId) {\n\t\t\t\t\t\tstart = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart = Math.min(Math.max(0, start), self.count());\n\n\t\t\t// Get the end\n\t\t\tvar end = Math.min(Math.max(0, start + count), self.count());\n\n\t\t\t// Get the list of posts\n\t\t\tvar items = [];\n\t\t\tfor (var i = start; i < end; i++) {\n\t\t\t\titems.push(postsIndex[i]);\n\t\t\t}\n\n\t\t\treturn items;\n\t\t};\n\n\n\n\t\t\n\n\t\t/**\n\t\t* Loads the blog index from stacktodo\n\t\t* @param success=undefined: executed on success\n\t\t* @param failure=undefined: executed on failure, given the http status and error\n\t\t* @return self\n\t\t*/\n\t\tself.load = function(success, failure) {\n\t\t\tns.stacktodo.core.jsoncors.get({\n\t\t\t\turl \t\t\t: 'https://stacktodo.com/api/tool/publish/posts' + indexUrlQuery,\n\t\t\t\tsuccess\t\t\t: function(response, status, xhr) {\n\t\t\t\t\tpostsIndex = response.posts;\n\t\t\t\t\t// Enhance the posts slightly\n\t\t\t\t\tfor (var i = 0; i < postsIndex.length; i++) {\n\t\t\t\t\t\tpostsIndex[i].index = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (success) { success(); }\n\t\t\t\t},\n\t\t\t\tfailure \t\t: function(status, error, xhr) {\n\t\t\t\t\tif (failure) { failure(status, error); }\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn self;\n\t\t};\n\n\t\t/**\n\t\t* Loads a post at the given index\n\t\t* @param postId: the id of the post to load\n\t\t* @param success=undefined: executed on load success. Provided with the html\n\t\t* @param failure=undefined: executed on load failure\n\t\t* @return self\n\t\t*/\n\t\tself.postForIndex = function(index, success, failure) {\n\t\t\tvar head = self.postHeadForIndex(index);\n\t\t\treturn self.postForId((head || {}).id, success, failure);\n\t\t};\n\n\t\t/**\n\t\t* Loads a post at the given index\n\t\t* @param postId: the id of the post to load\n\t\t* @param success=undefined: executed on load success. Provided with the html\n\t\t* @param failure=undefined: executed on load failure\n\t\t* @return self\n\t\t*/\n\t\tself.postForId = function(postId, success, failure) {\n\t\t\tsuccess = success || function() {};\n\t\t\tfailure = failure || function() {};\n\n\t\t\tif (posts[postId]) {\n\t\t\t\tsetTimeout(function() { success(posts[postId]); }, 1);\n\t\t\t} else {\n\t\t\t\tvar head = self.postHeadForId(postId);\n\t\t\t\tif (head === undefined) {\n\t\t\t\t\tsetTimeout(function() { failure(-1, 'IndexNotLoadedError'); });\n\t\t\t\t} else {\n\t\t\t\t\tns.stacktodo.core.ajax.get({\n\t\t\t\t\t\turl \t\t: head.url + '?ts=' + new Date().getTime(),\n\t\t\t\t\t\tsuccess \t: function(response, status, xhr) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = JSON.parse(response);\n\t\t\t\t\t\t\t} catch(ex) {\n\t\t\t\t\t\t\t\tfailure(-1, 'JSONParseError');\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Enhance the post\n\t\t\t\t\t\t\tresponse.html = response.html.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n\t\t\t\t\t\t\tresponse.id = head.id;\n\t\t\t\t\t\t\tresponse.url = head.url;\n\t\t\t\t\t\t\tresponse.index = head.index;\n\n\t\t\t\t\t\t\t// Save and respond\n\t\t\t\t\t\t\tposts[postId] = response;\n\t\t\t\t\t\t\tsuccess(response);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfailure \t: function(status, error, xhr) {\n\t\t\t\t\t\t\tfailure(status, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn self;\n\t\t};\n\n\t\t/**\n\t\t* Loads a set of posts. Silently validates if the start or end falls outside the bounds of posts\n\t\t* @param lastId=null: the id of the last post. This will load the next one\n\t\t* @param count: the number of posts to load\n\t\t* @param success=undefined: executed on load success. Provided with a list of html strings\n\t\t* @param failure=undefined: executed on load failure\n\t\t* @return self\n\t\t*/\n\t\tself.postset = function(lastId, count, success, failure) {\n\t\t\tsuccess = success || function() {};\n\t\t\tfailure = failure || function() {};\n\n\t\t\tvar heads = self.nextPostHeadsForRange(lastId, count);\n\t\t\tif (heads === undefined) {\n\t\t\t\tsetTimeout(function() { failure(-1, 'IndexNotLoadedError'); });\n\t\t\t} else if (heads.length === 0) {\n\t\t\t\tsetTimeout(function() { success({}); });\n\t\t\t} else {\n\t\t\t\t// Setup our return map\n\t\t\t\tvar hasError = false;\n\t\t\t\tvar requests = {};\n\t\t\t\tfor (var i = 0; i < heads.length; i++) {\n\t\t\t\t\trequests[heads[i].id] = null;\n\t\t\t\t}\n\n\t\t\t\t// Fire all the requests off (the browser will limit the quantity we are able to make here)\n\t\t\t\tfor (var i = 0; i < heads.length; i++) {\n\t\t\t\t\t(function(id, url) {\n\t\t\t\t\t\tself.postForId(id, function(post) {\n\t\t\t\t\t\t\tif (hasError) { return; }\n\t\t\t\t\t\t\trequests[id] = post;\n\n\t\t\t\t\t\t\tfor (var k in requests) {\n\t\t\t\t\t\t\t\tif (requests[k] === null) { return; }\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Catch the final one here\n\t\t\t\t\t\t\tsuccess(requests);\n\t\t\t\t\t\t}, function(status, error) {\n\t\t\t\t\t\t\tif (hasError) { return; }\n\t\t\t\t\t\t\thasError = true;\n\t\t\t\t\t\t\tfailure(status, error);\n\t\t\t\t\t\t});\n\t\t\t\t\t})(heads[i].id, heads[i].url);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn self;\n\t\t};\n\n\t\t/**\n\t\t* Invalidates a post so it will be refetched from the server next time it's called\n\t\t* @param postId: the id of the post to invalidate\n\t\t* @return self\n\t\t*/\n\t\tself.invalidatePost = function(postId) { delete posts[postId]; return self; };\n\n\t\t/**\n\t\t* Invalidates all the posts so they must be refetched from the server\n\t\t* @return self\n\t\t*/\n\t\tself.invalidatePosts = function() { posts = {}; return self; }\n\n\t\t/**\n\t\t* Invalidates the index so it must be refetched from the server\n\t\t* @return self\n\t\t*/\n\t\tself.invalidateIndex = function() { postsIndex = null; return self; };\n\n\t\treturn self;\n\t};\n\n\tns.stacktodo = ns.stacktodo || {};\n\tns.stacktodo.SlackPublish = SlackPublish;\n})(window);"]}